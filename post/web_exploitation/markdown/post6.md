# [xss-game] Level 1 - 6
## Level 1
<p>Dòng 45, biến query được lấy từ tham số query trên URL được nối chuỗi trực tiếp vào HTML. Sau đó, được render ra cùng với header và footer.</p>

![alt text](/thanhlai/post/web_exploitation/image/post6/image.png)

<p>Sử dụng tag script để trigger XSS: &lt;script&gt;alert(origin)&lt;/script&gt;</p>

![alt text](/thanhlai/post/web_exploitation/image/post6/image-1.png)

## Level 2
<p>Dòng 42 - 46, lấy nội dung được post lên lưu vào DB và hiển thị lại danh sách post sau khi cập nhật</p>

![alt text](/thanhlai/post/web_exploitation/image/post6/image-2.png)

<p>Hàm displayPosts có chức năng chính là duyệt qua tất cả posts, nối các chuỗi HTML (chứa message chính là nội dung post của user) và cập nhật bằng hàm innerHTML. Các message hoàn toàn không được escape HTML + innerHTML -> XSS</p>

![alt text](/thanhlai/post/web_exploitation/image/post6/image-3.png)

<p>Hiện tại, nếu chèn tag script bằng innerHTML thì trình duyệt sẽ không thực thi. Thay vào đó, sử dụng các tag khác như: img, svg,... để trigger XSS -> Payload: &lt;img src=x onerror=alert(origin)&gt;</p>

![alt text](/thanhlai/post/web_exploitation/image/post6/image-4.png)

## Level 3
<p>Đầu tiên, biến num trong hàm chooseTab được lấy từ URL fragment (sau kí tự # trên URL). Dòng 16 - 17 thực hiện ghép chuỗi HTML để hiển thị hình ảnh với đường dẫn động. Dòng 18 sử dụng jQuery để cập nhật nội dung HTML của phần tử có id là tabContent -> Có khả năng bị XSS. Tuy nhiên, cần kiểm tra xem parseInt() xử lý như thế nào khi chứa payload XSS.</p>

![alt text](/thanhlai/post/web_exploitation/image/post6/image-5.png)

<p>Thử &lt;h1&gt; thì parseInt(num) trả về NaN và vẫn nối chuỗi như thường</p>

![alt text](/thanhlai/post/web_exploitation/image/post6/image-6.png)

<p>Sử dụng '>< để kéo dài nội dung html và white_space' để đóng chuỗi .jpg -> Payload: &#39;&gt;&lt;img src=x onerror=alert(origin)&gt; '</p>

![alt text](/thanhlai/post/web_exploitation/image/post6/image-7.png)

## Level 4
<p>Đầu tiên, nếu chứa tham số timer trên URL thì trả về template timer.html với giá trị timer. Ngược lại thì trả về index.html. Tiếp theo, cần tìm hiểu timer.html được render cùng với input như thế nào.</p>

![alt text](/thanhlai/post/web_exploitation/image/post6/image-9.png)

<p>Trong timer.html, biến timer được nhúng vào 2 nơi là dòng 21 và 23 -> Có khả năng bị XSS</p>

![alt text](/thanhlai/post/web_exploitation/image/post6/image-8.png)

<p>Thử &lt;script&gt;alert(origin)&lt;/script&gt; và kết quả đã bị escape. Có vẻ như template đã tự động html entity encode biến timer -> Dòng 23 không bị XSS.</p>

![alt text](/thanhlai/post/web_exploitation/image/post6/image-10.png)

<p>Dòng 21, biến timer được nhúng vào làm đối số của hàm startTimer. Tương tự lv3, vẫn sử dụng cách nối dài payload kết hợp với // để comment ') -> Payload: '); alert(origin)//</p>

![alt text](/thanhlai/post/web_exploitation/image/post6/image-11.png)

## Level 5
<p>Đầu tiên, tham số next được nhúng vào template confirm.html và là giá trị URL dùng để chuyển hướng.</p>

![alt text](/thanhlai/post/web_exploitation/image/post6/image-13.png)

<p>Sử dụng giao thức javascript để trigger XSS -> Tham số next=javascript:alert(origin)</p>

![alt text](/thanhlai/post/web_exploitation/image/post6/image-12.png)

## Level 6
<p>Đầu tiên, dòng 46 gọi hàm includeGadget và đối số là kết quả trả về của hàm getGadgetName. Quan sát, hàm getGadgetName trả về phần sau # hoặc mặc định là /static/gadget.js </p>

![alt text](/thanhlai/post/web_exploitation/image/post6/image-15.png)

<p>Đi vào hàm includeGadget: đầu tiên, tạo một phần tử script và kiểm tra xem url nếu khớp với http/https thì hiển thị phần tử log với nội dung là không thể load URL chứa http và kết thúc hàm.</p>

![alt text](/thanhlai/post/web_exploitation/image/post6/image-16.png)

<p>Tiếp theo, gán url vào thuộc tính src của phần tử script vừa tạo. Đoạn code còn lại dùng để in ra thông báo log. Vì hàm setInnerText sử dụng innerText và textContent nên chỉ hiển thị dưới dạng text mà không thực thi HTML -> Vậy nơi có thể bị XSS còn lại là thuộc tính src của phần tử script. Vì http/https đã bị filter bởi regex ở trên nên không thể load một tệp js bằng thông qua URL. Tuy nhiên, ngoài cách nhúng URL thì còn có thể nhúng js code dưới dạng data: vào thuộc tính src.</p>

![alt text](/thanhlai/post/web_exploitation/image/post6/image-17.png)

<p>Payload: data:text/javascript,alert(origin) -> Trigger XSS thành công.</p>

![alt text](/thanhlai/post/web_exploitation/image/post6/image-14.png)

<p>Tóm lại, đây là toàn bộ nội dung về challenge. Hy vọng writeup này giúp ích cho bạn 🔥.</p>
