# Charlies_Angels
<p>Trong file app.py của thư mục py,  endpoint /backup dùng để sao lưu dữ liệu theo hai cách: nhận file được tải lên hoặc nhận dữ liệu dưới dạng JSON. Dòng 15, dùng danh sách BANNED để chặn tải lên các file như app.py, flag và requirements.txt. Chuỗi <code>..</code> bị cấm trong filename. Sau đó, file được ghi vào thư mục backups. Nếu sử dụng JSON thì lấy id để tạo tên file và ghi nội dung từ angel vào.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-5.png)

<p>Endpoint /restore thực hiện chạy script nếu đường dẫn hợp lệ -> Có thể RCE nếu upload được file python. Mà ở endpoint /backup cho phép tải lên file để sao lưu. Kết hợp lại thì có thể upload file lên /backup và truy cập vào /restore với id là filename để thực thi script.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-6.png)

<p>Tuy nhiên, services py không thể truy cập từ bên ngoài và chỉ có thể cập thông qua services node.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-7.png)

<p>Trong file index.js của thư mục node, dòng 59 thực hiện POST nội dung lên http://localhost:1338/backup -> Dựa vào điều này để gửi file qua /backup. Dòng 55, giá trị của angel trong data được lấy từ req.session.angel. Mà req.session.angel được lấy từ req.body.angel nên có thể kiểm soát được phần tử angel trong data khi POST lên http://localhost:1338/backup.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-3.png)

<p>Endpoint /restore, truy cập tới http://localhost:1338/restore với id là sessionID -> Chỉ có thể truy cập bằng sessionID -> Tên file upload tới /backup phải có filename trùng với sessionID.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-4.png)

<p>Thử POST lên /angel một object có sẵn chứa phần tử angel và đổi giá trị của Content-Type sang application/json. Kết quả trả về là sessionID.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image.png)

<p>Kiểm tra thư mục backups thì thấy chưa có file nào được tạo ra -> Có vẻ là do HTTP request của node gửi qua py không chính xác hoặc do nguyên nhân nào đó.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-10.png)

<p>Thử bắt lại HTTP request bằng cách gửi qua burp suite trước khi đến /backup bằng đoạn code sau:</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-11.png)

<p>Có vẻ như do thiếu <code>filename="abc"</code> nên không thể truy cập vào filename và dẫn đến việc ghi dữ liệu không thành công. Các giá trị của name trong header Content-Disposition đều sử dụng [key] để thể hiện từng key của angel khi gửi dữ liệu đi. Còn phần body là giá trị của từng key cụ thể.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-9.png)

<p>Thử thêm <code>"</code> vào sau name để kiểm tra xem có thể inject vào giá trị của name trong header Content-Disposition không.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-16.png)

<p>Kết quả là <code>"</code> đã đóng lại chuỗi giá trị -> Có thể inject được.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-15.png)

<p>Thử <code>"; filename="abc.py"</code> -> Chèn được filename thành công. Chưa rõ hai kí tự thừa sau filename có gây lỗi không -> Tạm thời để đó.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-17.png)

<p>Bây giờ, cần lấy ra sessionID để đặt tên file.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-18.png)

<p>Dùng sessionID làm filename để inject vào name -> Kết quả là không có file nào được ghi (chưa rõ nguyên nhân).</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-19.png)

<p>Thử cách trên với các key còn lại -> Với các key trong angel.talents thì tạo file thành công. </p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-20.png)

<p>Truy cập /restore -> Script được thực thi và trả về nội dung flag.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-1.png)

# Log_Me_In
<p>Trong routes.py, endpoint /login thực hiện kiểm tra username/password và set cookie để đăng nhập. Password đã được hash bằng hàm sha265 nên không inject vào trường này được. Username thì được kiểm tra bởi hàm is_alphanumeric. Cuối cùng, trả về cookie từ thông tin user.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-21.png)

<p>Endpoint /register cũng kiểm tra username/password tương tự như login.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-22.png)

<p>Hàm is_alphanumeric sử dụng biểu thức chính quy để giới hạn kí tự -> Không có SQL injection -> Có vẻ như sẽ phải exploit cookie.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-28.png)

<p>Tại endpoind /user, dòng 87 trả về nội dung flag nếu uid của userinfo bằng 0. Biến userinfo là kết quả sau khi decode cookie.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-23.png)

<p>Hàm decode giải mã chuỗi hex (giá trị cookie) đó về lại dictionary bằng cách thực hiện XOR. Có thể tận dụng hàm encode có sẵn để tạo nên cookie có uid bằng 0. Tuy nhiên, vẫn chưa có ENCRYPT_KEY thực sự nên phải tìm cách để leak ra.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-24.png)

<p>Tận dụng hàm encode có sẵn, thay đổi cặp giá trị dùng để XOR thành dictionary ban đầu và giá trị cookie info -> Lấy ra được giá trị ENCRYPT_KEY.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-29.png)

<p>Tuy nhiên, mới chỉ leak được 1 phần giá trị -> Có vẻ cần phải làm cho dictionary dài ra thì mới leak được toàn bộ key. Trường username và displayname đều được phép tối đa là 50 kí tự.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-210.png)

<p>Khi thử tối đa 50 kí tự cho cả 2 trường và thay đổi cookie mới thì khi so sánh vẫn chưa leak ra hết được. Tuy nhiên, vì hàm encode và decode đều XOR theo từng byte nên độ dài của khóa chỉ cần lớn hơn hoặc bằng độ dài của cookie là kết quả vẫn chính xác.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-2.png)

<p>Thử decode cookie hiện tại, uid hiện tại đang là 1.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-26.png)

<p>Thay đổi uid thành 0 và encode lại là xong.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-27.png)

<p>Cập nhật giá trị cookie và refresh để nhận flag.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-30.png)

# Lost_Pyramid
<p>Trong app.py, endpoint /entrance tạo ra một token với khóa là PRIVATE_KEY, thuật toán là EdDSA để làm giá trị của cookie pyramid.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-40.png)

<p>Endpoint /scarab_room nhận tham số name. Sau đó, duyệt qua từng kí tự và chỉ giữ lại các kí tự hợp lệ (chữ cái A-Z, a-z hoặc số 0-9).</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-31.png)

<p>Biến name được đưa trực tiếp vào template trước khi render -> Có thể exploit qua SSTI. Tuy nhiên, đã giới hạn các kí tự đặc biệt nên không thể RCE được. Nhưng vẫn có thể leak được thông tin (PUBLICKEY, ...).</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-32.png)

<p>Endpoint /kings_lair, thực hiện kiểm tra giá trị cookie của user. Dòng 131, giải mã cookie với khóa là PUBLICKEY và thuật toán là một giá trị bất kì trong mảng trả về. Vì thuật toán là giá trị bất kì trong mảng (kết quả trả về của get_default_algorithms()) nên ưu tiên chọn thuật toán mã hóa đối xứng (1 PUBLICKEY là đủ). Tận dụng SSTI để leak giá trị của KINGSDAY để thỏa điều kiện vế thứ nhất của dòng 132. Còn ROLE thì thay đổi giá trị thành royalty trước khi encode là được. Nếu thỏa mãn điều kiện sẽ trả về kings_lair.html.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-33.png)

<p>Trong kings_lair.html, có trả về nội dung flag -> Mục tiêu đúng là exploit qua cookie.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-39.png)

<p>Nhập giá trị của name là <code>{{PUBLICKEY}}</code> và enter để leak ra giá trị.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-34.png)

<p>Tương tự, nhập giá trị của name là <code>{{KINGSDAY}}</code> và enter để leak ra giá trị.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-35.png)

<p>Tạo script bằng python dùng để exploit cookie (lưu ý: tải đúng phiên bản của jwt - PyJWT==2.3.0)</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-36.png)

<p>Cập nhật giá trị cookie và refresh -> Nội dung flag đã được hiển thị ra.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-37.png)

# Playing_on_the_Backcourts
<p>Trong app_public.py, sink xuất hiện ở dòng 115 có thể dẫn đến RCE. Endpoint /get_eval lấy giá trị của key 'expr' và đưa vào hàm deep_eval để lấy giá trị trả về.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-50.png)

<p>Thử chuỗi <code>1 + 2</code> và giá trị result trong response trả về là 3 -> Hàm eval đã thực thi chuỗi trên và trả về kết quả.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-42.png)

<p>Tiếp theo, chèn os command với lệnh là <code>whoami</code>. Kết quả vẫn trả về như bình thường.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-43.png)

<p>Chưa rõ nội dung flag nằm ở đâu -> Sử dụng <code>ls</code> để liệt kê các file trong mã nguồn.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-41.png)

<p>Khi xem lại app_public.py thì có giá trị của một biến giá giống cấu trúc flag -> Có vẻ như flag là giá trị của biến safetytime.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-45.png)

<p>Tìm thấy chuỗi có cấu trúc giống flag trong app.py. Tuy nhiên, khi thử submit thì đây không phải là flag.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-44.png)

<p>Thử đọc nội dung leaderboard.txt.enc thì không thành công. Có vẻ như dữ liệu trong file đã được mã hóa.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-46.png)

<p>Khả năng cao là trong Dockerfile sẽ chứa câu lệnh để mã hóa thành leaderboard.txt.enc -> Tìm thấy câu lệnh dùng để mã hóa với pass là giá trị của biến môi trường PASSPHRASE.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-47.png)

<p>In ra giá trị của biến môi trường PASSPHRASE -> Leak được giá trị thành công. Tiếp theo, cần phải giải mã nội dung file.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-48.png)

<p>Sử dụng base64 encode để lấy nội dung ra.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-49.png)

<p>Decode chuỗi base64 và lưu vào file leaderboard.txt.enc trên local. Vì trong base64 không có kí tự \n nên cần thay thế bằng tổ hợp (shift + enter).</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-410.png)

<p>Bắt đầu giải mã nội dung leaderboard.txt.enc. Có warning xuất hiện nhưng không cần quan tâm vì việc giải mã đã được thực hiện xong.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-411.png)

<p>Đọc nội dung sau khi giải mã -> Tìm thấy nội dung flag.</p>

![alt text](/thanhlai/post/web_exploitation/image/post9/image-412.png)

<p>Tóm lại, đây là toàn bộ nội dung về challenges. Hy vọng writeup này giúp ích cho bạn 🔥.</p>


