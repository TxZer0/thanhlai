# [OverTheWire] Natas Level 0 - 27
## Level 0
<p>View page source: tìm thấy comment chứa password của level 1.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image.png)

## Level 1
<p>Khi nhấn nút phải chuột thì hiển thị alert có nội dung nút phải đã bị chặn.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-1.png)

<p>Ngoài cách nhấn phải chuột và chọn chức năng View page source thì còn có thể thực hiện bằng tổ hợp phím Ctrl + U hoặc thêm view-source: vào đầu URL -> Tìm thấy comment chứa password của level 2.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-2.png)

## Level 2
<p>View page source: điều đáng chú ý là đường dẫn files/pixel.png.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-3.png)

<p>Truy cập vào đường dẫn tới ảnh -> Nội dung cũng không có gì đặc biệt.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-4.png)

<p>Thử truy cập thư mục files -> Tính năng directory listing đang được bật. Trong thư mục có một file users.txt rất khả nghi.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-5.png)

<p>Truy cập /files/users.txt -> Tìm thấy password của level 3.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-6.png)

## Level 3
<p>Nội dung comment có vẻ như muốn gợi ý truy cập đến /robots.txt.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-7.png)

<p>Phát hiện ra một đường dẫn /s3cr3t/ khá đặc biệt trong robots.txt.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-8.png)

<p>Thử truy cập vào /s3cr3t/ -> Tính năng directory listing đang được bật. Như ở level trước cũng có một file users.txt.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-9.png)

<p>Truy cập /s3cr3t/users.txt -> Tìm thấy password của level 4.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-10.png)

## Level 4
<p>Dựa vào nội dung thông báo thì có vẻ như trang web hiện tại chỉ cho phép truy cập từ địa chỉ http://natas5.natas.labs.overthewire.org/</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-11.png)

<p>Để thay đổi nguồn truy cập đến trang web hiện tại thành http://natas5.natas.labs.overthewire.org/ -> Thay đổi trường Referer ở trong HTTP headers có giá trị là http://natas5.natas.labs.overthewire.org/. Note: trường Referer chứa thông tin (URL) về trang web trước đó mà người dùng đã truy cập, tức là trang web đã đưa họ đến trang hiện tại. -> Gửi request với headers đã thay đổi -> Tìm được password của level 5.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-12.png)

## Level 5
<p>Có vẻ như cần phải đăng nhập để lấy thông tin xác thực (cookie, token, ...) gì đó trước khi vào trang hiện tại.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-13.png)

<p>Trong headers của response trả về có một trường Set-Cookie có giá trị loggedin=0 -> Có vẻ cookie này dùng để chứng minh là user đã đăng nhập rồi. Dựa vào giá trị là 0 -> Đoán rằng giá trị bằng 0 (chưa đăng nhập) và 1 (đã đăng nhập).</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-14.png)

<p>Thay đổi giá trị cookie loggedin thành 1 -> Tìm được password của level 6.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-15.png)

## Level 6
<p>Đầu tiên, if(array_key_exists("submit", $_POST)) kiểm tra xem user đã click vào nút submit hay chưa. Nếu có, so sánh nội dung nhập vào với giá trị của biến $secret để in ra password của level 7. Vì biến $secret nằm trong includes/secret.inc nên không rõ giá trị là gì. Tuy nhiên, dòng code so sánh secret sử dụng == thay vì === -> Có thể khai thác bằng lỗi type juggling.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-16.png)

<p>Trước tiên, thử xem server này có nhận dữ liệu dưới dạng JSON không bởi vì JSON chứa nhiều kiểu dữ nên dễ khai lỗi type juggling hơn. Kết quả không có thông báo đúng hay sai -> Có vẻ như không chấp nhận định dạng JSON -> Hướng sử dụng JSON đã fail.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-17.png)

<p>Quay lại, lúc nãy có include đường dẫn includes/secret.inc -> Thử truy cập để kiểm tra xem user có quyền đọc nội dung file này không. Kết quả là tìm thấy giá trị của biến $secret.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-18.png)

<p>Nhập secret và submit -> Tìm được password của level 7.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-19.png)

## Level 7
<p>Đầu tiên, có 2 liên kết đến trang Home và Page. Khi click vào trang Home thì gửi request đến /index.php với tham số page=home. Với trang About thì tham số page=about -> Có vẻ như tham số page dùng để xác định trang sẽ được trả về. Có thể đoạn code dùng để trả về từng trang cụ thể có dạng: include($_GET['page']."php"); hoặc là sử dụng hàm require.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-20.png)

<p>Thêm đuôi .php thì trả về warning home.php không tồn tại -> Có vẻ như include($_GET['page']); mới chính xác -> Có thể nhận cả đường dẫn tương đối và tuyệt đối.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-21.png)

<p>Gợi ý: password của level 8 nằm ở /etc/natas_webpass/natas8</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-22.png)

<p>Thay đổi giá trị tham số page thành /etc/natas_webpass/natas8 -> Tìm được password của level 8.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-23.png)

## Level 8
<p>Đầu tiên, input sẽ được mã hóa qua hàm encodeSecret. Sau đó, so sánh chuỗi sau khi mã hóa với giá trị $encodedSecret bằng nhau thì in ra password. Cách thức mà hàm encodeSecret mã hóa: encode base64 -> đảo ngược chuỗi -> chuyển sang dạng hex -> Hàm dùng để giải mã sẽ thực hiện như sau: chuyển hex về chuỗi gốc -> đảo ngược chuỗi -> decode base64.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-24.png)

<p>Đưa giá trị $encodedSecret vào hàm giải mã để tìm ra chuỗi cần nhập vào.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-25.png)

<p>Nhập secret và submit -> Tìm được password của level 9.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-26.png)

## Level 9
<p>Đầu tiên, $key được lấy từ $_REQUEST (gửi qua GET hoặc POST đều được). Sau đó, $key được chèn trực tiếp vào chuỗi lệnh trong hàm passthru -> Command injection.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-27.png)

<p>Thử <code>;ls;</code> để liệt kê các file trong thư mục hiện tại -> Không tìm thấy file nào có dấu hiệu chứa password. Trong level 7, file chứa password là /etc/natas_webpass/natas8 -> Có thể file chứa password của level này nằm ở /etc/natas_webpass/natas10.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-28.png)

<p>Sử dụng cat để đọc nội dung file: <code>;cat /etc/natas_webpass/natas10;</code> -> Tìm được password của level 10.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-29.png)

## Level 10
<p>Tương tự level trước đó, tuy nhiên lúc này đã có hàm preg_match để filter các kí tự ; | & . Ngoài cách là nối dài câu lệnh thì còn thể thêm một câu lệnh mới bằng cách xuống hàng -> Sử dụng kí tự xuống dòng để ngắt câu lệnh muốn thực thi thành 1 câu lệnh riêng biệt.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-30.png)

<p>Để truyền qua URL thì cần encode kí tự xuống dòng thành %0a (kí tự xuống dòng có mã ASCII là 0x0A, khi encode URL thì cần thêm % trước 0A)</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-31.png)

<p>Thay đổi lệnh ls thành <code>cat /etc/natas_webpass/natas11</code> -> Tìm được password của level 11.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-32.png)

## Level 11
<p>Để lấy được password thì $data["showpassword"] phải bằng yes. Đầu tiên, $data được lấy từ kết quả của loadData($defaultdata).</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-33.png)

<p>Mặc định, $defaultdata['showpassword'] có giá trị là no. Phân tích từ dòng $mydata['showpassword'] được set bằng $tempdata['showpassword']. Để giá trị được set thì phải thỏa 2 điều kiện if. Lệnh if thứ hai thỏa vì mặc định giá trị của bgcolor là #ffffff -> Match với regex rồi nên không cần thiết phải thay đổi. Lệnh if thứ nhất kiểm tra xem $tempdata có phải là mảng và chứa cả hai key "showpassword" và "bgcolor" hay không.  $tempdata phụ thuộc vào giá trị của cookie data -> Mục tiêu: làm cho kết quả trả về của hàm json_decode là array( "showpassword"=>"yes", "bgcolor"=>"#ffffff").</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-34.png)

<p>Trong hàm saveData, giá trị của cookie data được tạo ra bằng cách: chuyển mảng thành chuỗi JSON -> xor với key -> encode base64. Tuy nhiên, hiện tại chưa biết giá trị của key là gì.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-35.png)

<p>Có thể tìm ra key bằng cách xor plaintext với ciphertext. Trong trường hợp này thì plaintext là chuỗi JSON sau khi encode mảng và ciphertext là giá trị của cookie data sau khi decode base64. Đầu tiên, cookie mặc định trả về là HmYkBwozJw4WNyAAFyB1VUcqOE1JZjUIBis7ABdmbU1GIjEJAyIxTRg=. Mảng mặc định là array( "showpassword"=>"yes", "bgcolor"=>"#ffffff") -> Kết quả key sau khi tính toán là eDWoeDWoeDWoeDWoeDWoeDWoeDWoeDWoeDWoeDWoe. Có vẻ như chuỗi eDWo đang được lặp lại. Vì hàm xor_encrypt() sử dụng $key[$i % strlen($key)] nên key sẽ được lặp lại tuần hoàn -> Có thể key thực sự chỉ là "eDWo".</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-36.png)

<p>Thay đổi giá trị của phần tử có key là showpassword thành yes. Sau đó, mô phỏng lại quy trình tạo ra cookie.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-37.png)

<p>Đưa giá trị mới vào cookie data và refresh lại trang -> Tìm được password của level 12.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-38.png)

## Level 12
<p>Đầu tiên, tạo một path bằng hàm makeRandomPathFromFilename với hai đối số là "upload" và $_POST['filename']. Nếu kích thước file upload lớn hơn 1KB thì thông báo rằng file có kích thước quá lớn. Ngược lại, di chuyển file upload từ thư mục tạm thời đến $target_path. Tiếp theo, tag input có name="filename" tự động tạo một filename bằng hàm genRandomString với đuôi .jpg -> Có thể kiểm soát được giá trị của $_POST['filename'].</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-39.png)

<p>Thử thay đổi giá trị của filename thành readme.txt -> File được lưu ở upload/sth.txt -> Có vẻ như chỉ kiểm soát được phần mở rộng còn tên file sẽ được random.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-40.png)

<p>Chính xác là do hàm makeRandomPathFromFilename đã gọi hàm makeRandomPath để tạo đường dẫn ngẫu nhiên nhưng thư mục thì vẫn cố định là "upload" và phần mở rộng phụ thuộc vào giá trị của filename.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-41.png)

<p>Upload file có đuôi .php + sử dụng hàm system() để thực thi lệnh shell từ tham số cmd trong URL -> Upload thành công.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-42.png)

<p>Truy cập vào file php đã upload, thêm tham số cmd bằng lệnh cat /etc/natas_webpass/natas13 -> Tìm được password của level 13.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-43.png)

## Level 13
<p>Tương tự như level trước, nhưng lần này có thêm một bước kiểm tra loại tệp để đảm bảo file upload là hình ảnh. Hàm exif_imagetype() được sử dụng cho mục đích này. Vậy nó xác định loại tệp dựa trên yếu tố nào? -> exif_imagetype() kiểm tra signature bytes ở đầu tệp để nhận diện định dạng ảnh. Ví dụ: với tệp GIF thì signature sẽ là GIF87a hoặc GIF89a. -> Chỉ cần thêm GIF89a vào đầu file là bypass thành công.</p>
 
![alt text](/thanhlai/post/web_exploitation/image/post7/image-44.png)

<p>Upload file có đuôi .php + sử dụng hàm system() để thực thi lệnh shell từ tham số cmd trong URL -> Upload thành công.</p>
 
![alt text](/thanhlai/post/web_exploitation/image/post7/image-45.png)

<p>Truy cập vào file php đã upload, lúc này chuỗi GIF89 được hiển thị trước khi thực thi PHP.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-46.png)
 
<p>Thêm tham số cmd bằng lệnh cat /etc/natas_webpass/natas14 -> Tìm được password của level 14.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-47.png)
 
## Level 14
<p>Để lấy password level 15, truy vấn cần trả về số dòng > 0. Giả sử: username=lai, password=thanh → Query:<code>SELECT * FROM users WHERE username="lai" AND password="thanh"</code>. Dùng <code>"OR 1=1#</code> để bypass kiểm tra → Trả về tất cả bản ghi nếu có dữ liệu trong bảng.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-48.png)

<p>Thay đổi giá trị username thành <code>"OR 1=1#</code> và encode URL. Tìm được password của level 15.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-49.png)

## Level 15
<p>Đầu tiên, chỉ được nhập username và kết quả in ra màn hình là một trong ba thông báo (user tồn tại, không tồn tại và có lỗi xảy ra). Khác với level trước là password của level sau sẽ xuất hiện sau khi đăng nhập thành công -> Dựa vào nội dung của thông báo (tồn tại, không tồn tại) thì mình đoán bài gợi ý sử dụng hai thông báo này như là một điều kiện true/false để kiểm tra giá trị gì đó. Hiện tại, có ba hướng có thể thử: ghi file để lấy web shell, thực thi OS command và leak từng kí tự (username, password,...) qua việc so sánh đúng/sai. Tuy nhiên, hướng thứ hai sẽ fail do lệnh EXEC phải được sử dụng riêng biệt và hầu như các biến bắt đầu từ mysqli.. -> Khả năng cao hệ cơ sở dữ liệu được sử dụng là MySQL.</p>
 
![alt text](/thanhlai/post/web_exploitation/image/post7/image-50.png)

<p>Thay giá trị username=<code>" UNION SELECT 1, UNHEX('3C3F7068702073797374656D28245F4745545B27636D64275D293B203F3E') INTO OUTFILE "/var/www/html/readme.php"#</code>, trong đó chuỗi hex là giá trị của code php sau khi chuyển sang hex. Kết quả in ra là error -> Có lẽ do không có quyền ghi file hoặc đường dẫn ghi vào bị sai. -> Hướng này có vẻ fail.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-51.png)

<p>Cuối cùng, còn lại hướng leak từng kí tự của (username, password,...) dựa trên tính đúng / sai (tồn tại / không tồn tại). Mình đoán cần phải leak ra username/password của level 16. Khả năng cao username chứa password của level 16 sẽ là natas16. Thử username=natas16 thì kết quả user có tồn tại -> Việc còn lại là leak ra password. Dựa vào độ dài password của những level trước thì password lưu trong database có thể cũng là 32 kí tự.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-52.png)

<p>Tạo <a href="/thanhlai/post/web_exploitation/script/level15.py">script</a> Python để brute-force từng ký tự của mật khẩu bằng cách dựa vào thông báo This user exists -> Tìm được password của level 16.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-53.png)

## Level 16
<p>Hàm preg_match sử dụng biểu thức chính quy để chặn các kí tự ; | & ` \ ' " -> Các kí tự khả dụng còn có thể sử dụng là $ ( ) space tab newline,... </p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-54.png)

<p>Đầu tiên, sử dụng $() chứa lệnh curl hoặc wget để kiểm tra xem có thể lấy nội dung file ra ngoài hay không. Sau khi thực thi lệnh, phản hồi trả về khá lâu. Tuy nhiên, không có request nào được gửi đến server bên ngoài. Điều này cho thấy có thể request đã bị chặn, curl/wget không tồn tại, hoặc có một nguyên nhân khác -> Hướng này có vẻ không khả thi.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-55.png)

<p>Thử ghi nội dung vào /var/www/html/test.txt. Command đã được thực thi nhưng khi truy cập vào /test.txt thì Not Found -> Có thể là do không có quyền ghi, đường dẫn sai,... -> Failed. </p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-56.png)

<p>Kết hợp if trong bash với time-based cũng không khả thi bởi vì đã chặn kí tự ; . Ý tưởng bây giờ là sử dụng biểu thức chính quy để kiểm tra từng kí tự. Vậy làm sao để nhận biết rằng kí tự trong flag có khớp với pattern hay không? -> Có thể tận dụng kết quả của output để kiểm tra đúng/sai bằng cách sau: chọn từ khóa (ví dụ: Africans) chỉ có duy nhất một kết quả -> Vậy thì khi nối với kí tự (ví dụ là a) trong flag sẽ ra kết quả là rỗng bởi vì trong dictionary.txt không có từ khóa Africansa.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-57.png)

<p>Sử dụng grep với option -o để chỉ hiển thị phần khớp với regex.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-58.png)

<p>Tạo <a href="/thanhlai/post/web_exploitation/script/level16.py">script</a> Python để brute-force từng ký tự của mật khẩu bằng cách dựa vào output -> Tìm được password của level 17.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-59.png)

## Level 17
<p>Khác với level 15 ở chỗ dòng in ra thông báo (tồn tại, không tồn tại, có lỗi xảy ra) đã bị comment -> Vậy không thể dựa vào thông báo để xác định từng kí tự trong password.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-60.png)

<p>Sử dụng SLEEP để hệ thống phản hồi chậm hơn. Sau đó, dựa vào thời gian phản hồi để xác định các kí tự trong password. Ví dụ: query <code>IF(BINARY SUBSTRING(password, 1, 1) = "a", SLEEP(2), 0)</code> kiểm tra nếu ký tự đầu tiên của mật khẩu là "a" <code>(BINARY SUBSTRING(password, 1, 1) = "a")</code>, thì server sẽ ngủ <code>SLEEP(2)</code> trong 2 giây, nếu sai thì trả về 0 (không ngủ). Tạo <a href="/thanhlai/post/web_exploitation/script/level17.py">script</a> Python để brute-force từng ký tự của mật khẩu bằng cách dựa vào thời gian phản hồi -> Tìm được password của level 18.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-61.png)

## Level 18
<p>Đầu tiên, gọi hàm my_session_start (có vẻ như dùng để kiểm tra tạo session hay chưa). Nếu thỏa điều kiện thì gọi hàm print_credentails để kiểm tra nếu đúng là phiên của admin thì in ra username/password của level tiếp theo. Ngược lại, tạo một session cho user và gán $_SESSION['admin'] bằng kết quả trả về của hàm isValidAdminLogin(). Session ID (cookie PHPSESSID) được tạo ra từ hàm createID với đối số là username. Có thể mục tiêu của bài này là lấy được session của admin.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-62.png)

<p>Hàm createId tạo ra giá trị của cookie PHPSESSID bằng cách random từ 1 đến giá trị $maxid (640). Vì giá trị của PHPSESSID luôn nằm trong khoảng 1 đến 640 nên admin cũng sẽ có PHPSESSID với giá trị nằm trong đoạn từ 1 đến 640.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-63.png)

<p>Tạo <a href="/thanhlai/post/web_exploitation/script/level18.py">script</a> để brute-force từ 1 đến 640. Dựa vào "You are an admin" trong response để xác định chính xác cookie của admin.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-64.png)

## Level 19
<p>Ở level này, id đã được nối chuỗi với username qua kí tự - rồi chuyển sang dạng hex bằng hàm bin2hex. Hàm isValidID dùng để chuyển chuỗi hex về lại chuỗi gốc bằng hàm myhex2bin rồi dùng regex để kiểm tra cấu trúc id-username -> Giá trị PHPSESSID của admin có cấu trúc: id(chưa rõ)-admin ở dạng hex.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-65.png)

<p>Thử chuyển giá trị của cookie sang chuỗi gốc -> Đúng cấu trúc: id-username rồi.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-66.png)

<p>Tạo <a href="/thanhlai/post/web_exploitation/script/level19.py">script</a> brute-force id từ 1 đến 640 -> Tìm được giá trị của PHPSESSID của admin.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-67.png)

<p>Thay đổi giá trị của cookie trên browser -> Tìm được password của level 20.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-68.png)

## Level 20
<p>Đầu tiên, gọi hàm session_set_save_handler để định nghĩa ra các hàm xử lý session trước khi bắt đầu session. Sau đó, nếu user gửi name đến server thì set $_SESSION['name'] bằng input. Tương tự, hàm print_credentials cũng được dùng để kiểm tra $_SESSION['admin'] = 1 thì in ra username/password.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-70.png)

<p>Trong các hàm xử lý session thì có hai hàm đáng chú ý là myread và mywrite.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-71.png)

<p>Thử var_dump $data và $filename thì hiểu được hàm mywrite ghi từng phần tử của $_SESSION dưới dạng key value vào file /tmp/mysess_giá_trị_của_PHPSESSID và hàm myread dùng để lấy từng phần tử trong file đó ra để lưu vào $_SESSION. Giả sử, name là laithanh thì sẽ được ghi thành name laithanh vào file chứa session. Khi đọc thì lấy name laithanh trong file chứa session lưu thành key và value của $_SESSION -> Nếu trong file chứa session có phần tử admin 1 thì sẽ lấy được session của admin.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-69.png)

<p>Thêm kí tự xuống dòng (%0A) với admin 1 để hàm mywrite ghi phần admin 1 vào file và ghi myread đọc file thì $_SESSION['admin'] sẽ được gán bằng 1. Note: (vì trong code hàm mywrite ghi mỗi phần từ sau đó (\n) xuống dòng rồi mới ghi phần tử tiếp theo nên mới thêm kí tự xuống dòng (%0A)), hàm myread cũng đọc mỗi dòng là một phần tử.  Lấy được session của admin -> Tìm thấy password của level 21.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-72.png)

## Level 21
<p>Mục tiêu vẫn là lấy được session của admin. Lần này thì cho thêm một đường link đến trang web khác có cùng domain -> Có vẻ như gợi ý rằng cookie của admin trên trang web (link) có thể dùng để lấy session của admin trên trang hiện tại. Tức là cookie có thể được áp dụng cho cả hai trang.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-75.png)

<p>Đoạn gây chú ý là hàm foreach dùng để duyệt các phần tử trong $_REQUEST và gán những phần tử đó vào $_SESSION -> Nếu thêm phần tử có key là admin và value là 1 thì $_SESSION sẽ lưu phần tử đó lại.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-76.png)

<p>Thêm trường admin=1 -> Trong session đã chứa admin = 1 -> Đưa giá trị PHPSESSID về trang web chính và lấy session admin.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-73.png)

<p>Cập nhật giá trị PHPSESSID -> Tìm được password của level 22.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-74.png)

## Level 22
<p>Đầu tiên, nếu chứa tham số revelio và không phải session của admin thì sử dụng hàm header để chuyển hướng quay trở lại trang. Tuy nhiên, bên dưới hàm header không dùng exit() hoặc die(),... nên đoạn mã bên dưới vẫn sẽ thực thi tiếp.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-78.png)

<p>Vì khi gặp header <code>Location: /</code> thì browser sẽ tự động chuyển hướng đến / và sẽ không thấy được đoạn mã thực hiện bên dưới -> Sử dụng burp suite để thấy được kết quả thực thi -> Tìm được password của level 23.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-77.png)

## Level 23
<p>Hàm strstr tìm kiếm chuỗi con trong chuỗi khác và trả về phần còn lại từ vị trí tìm thấy (ví dụ: <code>echo strstr("Hi, iloveyou123", "iloveyou");</code> . Kết quả: iloveyou123). Tiếp theo, để thỏa chuỗi > 10 thì chuỗi phải bắt đầu từ chữ số > 10 (ví dụ: 11). Kết hợp hai điều kiện trên thì payload phải có dạng: [số_lớn_hơn_10]iloveyou.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-79.png)

<p>Chọn payload: 123iloveyou -> Tìm được password của level 24.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-82.png)

## Level 24
<p>Hàm strcmp so sánh password nhập vào có khớp với password của level 25 hay không. Cách hoạt động: nếu 2 password khớp thì trả về 0 và !0 là 1 -> Thỏa điều kiện. Ý tưởng bây giờ là tìm cách nào nó để biểu thức strcmp(p1, p2) trả về một trong các giá trị như: false, 0, "", NULL, array(),... để khi phủ định sẽ thỏa điều kiện.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-85.png)

<p>Tìm ra một cách có thể khiến strcmp trả về NULL. Đó là truyền vào một array. Tài liệu tham khảo: <a href="https://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20PHP%20loose%20comparison%20-%20Type%20Juggling%20-%20OWASP.pdf">document</a> -> Thay đổi tham số passwd thành một array bằng passwd[] -> Tìm ra password của level 25.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-83.png)

## Level 25
<p>Đầu tiên, gọi hàm setLanguage dùng để trả về đúng nội dung cho từng ngôn ngữ.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-87.png)

<p>Hàm setLanguage lấy ra giá trị tham số lang để kiểm tra. Tiếp theo, nối vào sau chuỗi "language/" rồi đưa vào hàm safeinclude như là một đường dẫn file. Hàm sageinclude nhận và kiểm tra $filename. Nếu chứa ../ thì bị replace thành rỗng -> Bypass bằng cách chèn một chuỗi ../ ở giữa. Tiếp tục, nếu $filename chứa "natas_webpass" thì exit -> Dùng để ngăn việc đọc file chứa password -> Không thể đọc trực tiếp nội dung file chứa password bằng lỗi path traversal. Tuy nhiên, trong khi kiểm tra thì có sử dụng hàm logRequest để ghi lại thông tin log. Trong hàm logRequest, nội dung của một lần ghi log bao gồm: message và giá trị của trường User-Agent trong http header. Cuối cùng, ghi vào /var/www/natas/natas25/logs/natas25_[session_id].log. Tóm lại, có thể khai thác bằng cách đưa PHP code vào trường User-Agent và tận dụng lỗi path traversal để include ra file log -> Thực thi OS command để đọc password.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-86.png)

<p>PHPSESSID đang có giá trị là 9eee5dqqqlb21obhgvdbp616l5 -> Đường dẫn tới file log là /var/www/natas/natas25/logs/natas25_9eee5dqqqlb21obhgvdbp616l5.log. Vì tham số lang nằm sau "language/" nên phải sử dụng ../ để quay về thư mục /. Để sau khi replace trở thành ../ thì phải thêm ../ vào giữa và  thành <code>..././</code>. Thêm <code>..././</code> vào trước cho đến khi include ra đúng đường dẫn file log. Thay nội dung của header User-Agent thành code PHP để thực thi OS command. Thêm tham số cmd=ls -> Liệt kê các file thành công.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-88.png)

<p>Thay đổi thành lệnh <code>cat /etc/natas_webpass/natas26</code> -> Tìm thấy password của level 26.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-90.png)

## Level 26
<p>Đầu tiên, kiểm tra điều kiện là tồn tại các tham số. Nếu thỏa thì gọi tạo ra đường dẫn file png và đưa vào hàm drawImage và showImage. Cuối cùng, gọi hàm storeData.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-94.png)

<p>Trong hàm storeData, nếu chứa cookie drawing thì thực hiện decode base64 rồi unserialize. Tuy nhiên, không có bất kì kiểm tra nào với cookie đó -> Dẫn đến lỗi PHP deserialization .</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-95.png)

<p>Tận dụng class Logger có sẵn để thực thi OS command. Chọn thư mục img để ghi file vì những image được lưu vào đây nên khả năng cao sẽ được quyền ghi vào. Khi object bị hủy -> Kích hoạt hàm __destruct -> Mở file log và thêm nội dung exitMsg vào. Thực hiện serialize object rồi encode base64 -> Có được cookie dùng để exploit.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-91.png)

<p>Cập nhật giá trị của cookie drawing và refresh. Tuy là có lỗi do một dòng code đã xem object như là một array nhưng việc unserialize đã được thực hiện trước đó rồi (xem lại hàm storeData sẽ rõ).</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-92.png)

<p>Truy cập vào img/calc.php -> OS command đã thực thi và trả về password.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-93.png)

u3RRffXjysjgwFU6b9xa23i6prmUsYne 

## Level 27
<p>Đầu tiên, đưa username vào hàm validUser để kiểm tra có tồn tại hay chưa. Nếu có thì kiểm tra tiếp username/password bằng hàm checkCredentials.Ngược lại, tạo ra một user mới bằng hàm createUser.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-96.png)

<p>Trong hàm checkCredentials và validUser đều sử dụng mysqli_real_escape_string để ngăn SQL injection nên không inject được trong trường hợp này.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-97.png)

<p>Trong hàm dumpData, username được loại bỏ (khoảng trắng, xuống dòng, tab,..) trước khi vào mysqli_real_escape_string.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-98.png)

<p>Trong hàm createUser, trước khi thêm user vào db thì sử dụng hàm trim để ngăn khoảng trắng xuất hiện ở đầu và cuối chuỗi. Tiếp theo, sử dụng hàm substr để lấy 64 kí tự đầu tiên.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-99.png)

<p>Ban đầu, ý tưởng dùng để bypass 2 hàm checkCredentials và validUser là tạo ra user có username=<code>'natas27  '</code> vì username này có khoảng trắng đằng sau nên khi vào hàm dumpData sẽ bị hàm trim loại bỏ khoảng trắng và $user sẽ chỉ còn là <code>natas27</code> -> Sau đó, data(password của level 28) sẽ được in ra. Tuy nhiên, vấn đề là khi có khoảng trắng ở sau thì sẽ bị kiểm tra trong createUser -> Phải thêm chữ ở sau khoảng trắng -> Như vậy sẽ khiến cho dumpData không trả về chính xác username=<code>'natas27'</code>. Vẫn còn một dữ kiện là substr lấy 64 kí tự đầu tiên của username -> Dựa vào việc này để loại bỏ chuỗi sau khoảng trắng. Tóm lại, payload có dạng: "natas28" + 57 khoảng trắng (64 - độ dài chuỗi "natas28") + "something" (ít nhất 1 kí tự).</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-100.png)

<p>Sau khi đăng ký thì username sẽ mất chữ a ở cuối vì bị substr loại.</p> 

![alt text](/thanhlai/post/web_exploitation/image/post7/image-101.png)

<p>Lúc này, khi rơi vào hàm dumpData thì bị loại bỏ khoảng trắng và username chỉ còn là natas28 -> Lấy được password của level 28.</p>

![alt text](/thanhlai/post/web_exploitation/image/post7/image-102.png)




