# [Intigriti] Challenge-0125
<p>Bắt đầu thử thách là một trang yêu cầu nhập tên của người dùng. Sau khi submit thì quay lại /challenge với tham số là text=name. Nhấn Close thì trở về trạng thái ban đầu.</p>

![alt text](/thanhlai/post/web_exploitation/image/post2/image.png)

<p>Tiếp theo, view page source để xem có gì đặc biệt không. Sau khi submit thì kích hoạt hàm redirectToText để xử lý form.</p>

![alt text](/thanhlai/post/web_exploitation/image/post2/image-1.png)

<p>Chức năng chính của hàm này là encode name thành giá trị hợp lệ trên URL rồi chuyển hướng đến /challenge với tham số text=name. Thông thường, window.location.href được gán ="javascript:alert(origin)" để kích hoạt được XSS. Tuy nhiên, trong trường hợp này window.location.href chuyển hướng một url sử dụng giao thức https nên không kích hoạt javascript ở đây được. Hướng đi tiếp theo là tìm nơi nhận và xử lý khi có tham số text.</p>

![alt text](/thanhlai/post/web_exploitation/image/post2/image-2.png)

<p>Từ dòng 229 đến 232, thực hiện gọi 2 hàm generateFallingParticles và checkQueryParam sau khi load lại trang web.</p>

![alt text](/thanhlai/post/web_exploitation/image/post2/image-3.png)

<p>Hàm generateFallingParticles thực hiện điều gì đó nhưng không liên quan đến việc xử lý input nên tạm thời bỏ qua.</p>

![alt text](/thanhlai/post/web_exploitation/image/post2/image-4.png)

<p>Hàm checkQueryParam chính xác là nơi xử lý tham số text cần tìm. Dòng 182, gọi hàm getParameterByName và đối số là text. Dòng 183, kiểm tra nếu tham số text tồn tại và hàm XSS trả về false thì thực hiện đoạn mã bên trong. Dòng 186, cập nhật nội dung HTML bằng một chuỗi có chứa giá trị của tham số text sau khi đi qua hàm getParameterByName -> XSS sink. Điều cần làm bây giờ là tìm hiểu 2 hàm getParameterByName và XSS hoạt động như thế nào.</p>

![alt text](/thanhlai/post/web_exploitation/image/post2/image-5.png)

<p>Bắt đầu với hàm getParameterByName trước. Vì đối số truyền vào là text nên biến name trong hàm này đang có giá trị là text. Dòng 164, gọi hàm replace để thêm \ vào trước kí tự [ hoặc ] trong chuỗi. Vì chuỗi đang là text nên không có chuỗi nào khớp nên giá trị vẫn là text. Dòng 165, tạo một regex gì đó có vẻ như để match với các tham số trên URL và dòng 166 thực hiện tìm kiếm trong URL. Cuối cùng, trả về giá trị của tham số sau khi decode.</p>

![alt text](/thanhlai/post/web_exploitation/image/post2/image-6.png)

<p>Chức năng chính của hàm XSS này là trả true nếu tồn tại kí tự < hoặc là > trên phần query string hoặc phần hash -> Nói chung, để hàm XSS trả về false thì sau kí tự ? trong URL không được phép chứa kí tự < hoặc là >.</p>

```
function XSS() {
    return  decodeURIComponent(window.location.search).includes('<')    || 
            decodeURIComponent(window.location.search).includes('>')    || 
            decodeURIComponent(window.location.hash).includes('<')      || 
            decodeURIComponent(window.location.hash).includes('>')
}
```
<p>Nói chung thì hàm getParameterByName lấy toàn bộ URL ra và sử dụng regex để tìm ra tham số text. Sau đó, hàm XSS lấy phần từ sau ? để kiểm tra nếu tồn tại < hoặc > thì false và không đi tới được sink. Vậy câu hỏi đặt ra là: "Làm thế nào để vừa thỏa regex mà không nằm sau kí tự ? trong URL?".</p>

<p>Bây giờ, cần phân tích cấu trúc của URL (ví dụ: http://example.com/path?query#fragment). Đầu tiên, cần loại ?query#fragment vì hàm XSS sẽ kiểm tra phần này. Đoạn https://example.com/ cũng không thể thay đổi vì thay đổi địa chỉ thì còn làm được gì nữa đâu -> Nơi duy nhất khả thi là phần path. Regex được dùng để tìm tham số text trong URL, bất kể nó ở dạng ?text=value1 hoặc &text=value2 đều thỏa mãn. Cuối cùng thì path phải có dạng: &text=value2 sẽ bypass được hàm XSS.</p>

<p>Tuy nhiên, khi thêm &amp;text=&lt;h1&gt;a vào phần path thì sẽ phát sinh thêm một vấn đề là truy cập vào một trang không tồn tại. Vậy thì có cách nào để thêm &amp;text=&lt;h1&gt;a mà đường dẫn vẫn di chuyển tới /challenge hay không ? Theo mình nhớ thì có một lỗi khi cấu hình Nginx dẫn đến path traversal.</p>

<p>Thử truy cập vào một đường dẫn không tồn tại thì xác định trang này sử dụng nginx làm web server.</p>

![alt text](/thanhlai/post/web_exploitation/image/post2/image-8.png)

<p>Để tránh bị tự động chuẩn hóa đường dẫn, mình sẽ encode URL kí tự / thành %2f Sau khi thử các trường hợp ..%2f và %2f.. thì phát hiện ra URL: `https://challenge-0125.intigriti.io/challenge/abc%2f..%2f..%2fchallenge` này trả về chính xác trang /challenge. </p>

![alt text](/thanhlai/post/web_exploitation/image/post2/image-7.png)

<p>Tiếp theo, sử dụng &lt;img src=x onerror=alert(origin)&gt;
 để trigger XSS.</p>

![alt text](/thanhlai/post/web_exploitation/image/post2/image-9.png)

<p>Tuy nhiên, path: `/challenge/&text=&lt;img src=x onerror=alert(origin)&gt;%2f..%2f..%2fchallenge` vẫn có thể rút ngắn hơn nữa bằng `/challenge/&text=&lt;img src=x onerror=alert(origin)&gt;%2f..`</p>

![alt text](/thanhlai/post/web_exploitation/image/post2/image-10.png)

<p>Tóm lại, đây là toàn bộ nội dung về challenge. Hy vọng writeups này giúp ích cho bạn 🔥.</p>

